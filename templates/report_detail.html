@app.route("/report/<int:report_id>")
def report_detail(report_id):
    u = current_user()
    if not u["username"]:
        return redirect(url_for("home"))

    db = SessionLocal()
    base = db.query(Report).get(report_id)
    if not base:
        db.close()
        flash("Report not found", "error")
        return redirect(url_for("dashboard"))
    if u["role"] == "client" and base.client != u["client_name"]:
        db.close()
        flash("Unauthorized", "error")
        return redirect(url_for("dashboard"))

    # Pull ALL rows for this Lab ID (PFAS = 13 rows; BPS = 1 row)
    rows = db.query(Report).filter(Report.lab_id == base.lab_id).all()
    db.close()

    # Decide panel: if any BPS row exists -> BPS report; else PFAS report
    has_bps = any(_is_bps(r.test) for r in rows)
    if has_bps:
        mode = "BPS"
        # Keep ONLY the BPS row(s)
        sel = [r for r in rows if _is_bps(r.test)]
        # collapse to single row (prefer the first that has a result)
        sel.sort(key=lambda r: (str(r.result or "") == "", r.id))
        primary = sel[0]
        # Build Sample/QC lists with a single analyte
        sample_rows = [{
            "analyte": "Bisphenol S",
            "result": _first_nonempty(primary.result),
            "mrl": _first_nonempty(primary.sample_mrl),
            "units": _first_nonempty(primary.sample_units),
            "dilution": _first_nonempty(primary.sample_dilution),
            "analyzed": _first_nonempty(primary.sample_analyzed),
            "qualifier": _first_nonempty(primary.sample_qualifier),
        }]
        mb_rows = [{
            "analyte": "Bisphenol S",
            "result": _first_nonempty(primary.mb_result),
            "mrl": _first_nonempty(primary.mb_mrl),
            "units": _first_nonempty(primary.mb_units),
            "dilution": _first_nonempty(primary.mb_dilution),
        }]
        ms1_rows = [{
            "analyte": "Bisphenol S",
            "result": _first_nonempty(primary.ms1_result),
            "mrl": _first_nonempty(primary.ms1_mrl),
            "units": _first_nonempty(primary.ms1_units),
            "dilution": _first_nonempty(primary.ms1_dilution),
            "fortified_level": _first_nonempty(primary.ms1_fortified_level),
            "pct_rec": _first_nonempty(primary.ms1_pct_rec),
            "pct_rec_limits": _first_nonempty(primary.ms1_pct_rec_limits),
        }]
        msd_rows = [{
            "analyte": "Bisphenol S",
            "result": _first_nonempty(primary.msd_result),
            "units": _first_nonempty(primary.msd_units),
            "dilution": _first_nonempty(primary.msd_dilution),
            "pct_rec": _first_nonempty(primary.msd_pct_rec),
            "pct_rec_limits": _first_nonempty(primary.msd_pct_rec_limits),
            "pct_rpd": _first_nonempty(primary.msd_pct_rpd),
            "pct_rpd_limit": _first_nonempty(primary.msd_pct_rpd_limit),
        }]

        # Push client/summary into `base` so the template can read r.*
        base.sample_name = _first_nonempty(base.sample_name, base.lab_id)
    else:
        mode = "PFAS"
        # Keep ONLY the 13 PFAS rows; group by analyte key; pick best row per analyte
        pfas_rows_by_key = {}
        for r in rows:
            if not _is_pfas(r.test):
                continue
            key = _norm_analyte_key(r.test)
            if key not in pfas_rows_by_key:
                pfas_rows_by_key[key] = []
            pfas_rows_by_key[key].append(r)

        # Pick one row per analyte with a simple preference (has result first)
        chosen = {}
        for key, items in pfas_rows_by_key.items():
            items.sort(key=lambda rr: (str(rr.result or "") == "", rr.id))
            chosen[key] = items[0]

        # Build ordered tables strictly in the 13-item order
        sample_rows, mb_rows, ms1_rows, msd_rows = [], [], [], []
        for key in PFAS_KEYS:
            r = chosen.get(key)
            if not r:
                # If the analyte is missing in file, we SKIP it (you can change to include an empty row if you prefer)
                continue
            disp = PFAS_KEY_TO_DISPLAY.get(key, r.test or "")
            sample_rows.append({
                "analyte": disp,
                "result": _first_nonempty(r.result),
                "mrl": _first_nonempty(r.sample_mrl),
                "units": _first_nonempty(r.sample_units),
                "dilution": _first_nonempty(r.sample_dilution),
                "analyzed": _first_nonempty(r.sample_analyzed),
                "qualifier": _first_nonempty(r.sample_qualifier),
            })
            mb_rows.append({
                "analyte": disp,
                "result": _first_nonempty(r.mb_result),
                "mrl": _first_nonempty(r.mb_mrl),
                "units": _first_nonempty(r.mb_units),
                "dilution": _first_nonempty(r.mb_dilution),
            })
            ms1_rows.append({
                "analyte": disp,
                "result": _first_nonempty(r.ms1_result),
                "mrl": _first_nonempty(r.ms1_mrl),
                "units": _first_nonempty(r.ms1_units),
                "dilution": _first_nonempty(r.ms1_dilution),
                "fortified_level": _first_nonempty(r.ms1_fortified_level),
                "pct_rec": _first_nonempty(r.ms1_pct_rec),
                "pct_rec_limits": _first_nonempty(r.ms1_pct_rec_limits),
            })
            msd_rows.append({
                "analyte": disp,
                "result": _first_nonempty(r.msd_result),
                "units": _first_nonempty(r.msd_units),
                "dilution": _first_nonempty(r.msd_dilution),
                "pct_rec": _first_nonempty(r.msd_pct_rec),
                "pct_rec_limits": _first_nonempty(r.msd_pct_rec_limits),
                "pct_rpd": _first_nonempty(r.msd_pct_rpd),
                "pct_rpd_limit": _first_nonempty(r.msd_pct_rpd_limit),
            })

        # Prefer summary fields from any PFAS row that has them, otherwise keep `base` values
        pick = rows[0]
        base.sample_name = _first_nonempty(base.sample_name, pick.sample_name, base.lab_id)
        base.prepared_by = _first_nonempty(base.prepared_by, pick.prepared_by)
        base.matrix = _first_nonempty(base.matrix, pick.matrix)
        base.prepared_date = _first_nonempty(base.prepared_date, pick.prepared_date)
        base.asin = _first_nonempty(base.asin, pick.asin)
        base.product_weight_g = _first_nonempty(base.product_weight_g, pick.product_weight_g)
        base.qualifiers = _first_nonempty(base.qualifiers, pick.qualifiers)
        base.phone = _first_nonempty(base.phone, pick.phone)
        base.email = _first_nonempty(base.email, pick.email)
        base.project_lead = _first_nonempty(base.project_lead, pick.project_lead)
        base.address = _first_nonempty(base.address, pick.address)

    # Render
    return render_template(
        "report_detail.html",
        user=u,
        r=base,
        sample_rows=sample_rows,
        mb_rows=mb_rows,
        ms1_rows=ms1_rows,
        msd_rows=msd_rows,
        mode=mode,
    )
